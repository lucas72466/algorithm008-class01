## 动态规划

### 什么是动态规划

Dynamic programming。 中文译作动态规划， 其实本质上并没有名字这么玄乎。 和递归，分治有着千丝万缕的关系。 下面通过一道例题来阐述这种演变， 揭开动态规划的面纱。

[62. Unique Paths](https://leetcode-cn.com/problems/unique-paths/)

![image-20200531212900761](C:\Users\20548\Desktop\tmp\leetcode62.png)

这道题求解的是从起点到终点的路径数总和。 首先就观察问题的重复性， 先从最基础的情况开始分析（用数学归纳法， 杜绝人肉递归！）， 例如2*2的方格，那么（1,1）的格子的走法就是（1,2）（2,1）这两个格子走法之和， 子问题就分析出来了。扩展到大格子也是同理， 当前格子的走法就是右格子和下格子走法之和， 以此类推， 直到超出边界或者达到终点。 那么很容易就可以想到用分治的方法来进行解题。 

C++的代码如下

```c++
class Solution {
public: 
    int uniquePaths(int m, int n){
        if(m <= 0 || n <= 0) return 0;
        if(m == 1 || n == 1) return 1;
        return uniquePaths(m-1,n) + uniquePaths(m,n-1);
    }
};
```

这就解决了这个问题， 但可以发现这种傻递归存在着大量重复的计算， 改进的思路是加入一个“备忘录”， 来保存已经计算过的中间结果， 这样就实现了为递归状态树剪枝。

C++的代码如下

```c++
class Solution {
public: 
    vector<vector<int>> a;
    int uniquePaths(int m, int n){
        a=vector<vector<int>>(m,vector<int>(n,0));
        return helper(m-1,n-1);
    }
    int helper(int m, int n){
        if(m < 0 || n < 0) return 0;
        if(m == 0 || n == 0) return 1;
        if(a[m][n] > 0) return a[m][n];
        a[m][n] = helper(m-1,n) + helper(m,n-1);;
        return a[m][n];
    }
};
```

可以发现， 每个节点都只被计算了一次， 减少了不必要的重复。 这是自顶而下的递归， 那么可不可以自底向上来计算答案呢。 答案是肯定的。

C++的代码如下

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int dp[m][n];
        for (int i=0; i<n; ++i) dp[0][i] = 1;
        for (int i=0; i<m; ++i) dp[i][0] = 1;
        for (int i=1; i<m; ++i){
            for (int j=1; j<n; ++j){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```

这样实现了从最基础的答案向上来“拼装”最后的答案， 用递推的方式来代替递归。 所以所谓动态规划其实翻译成动态递推更为妥当。



可以发现， 动态规划就是从最基础的暴力分治法一步步优化而来的， 自底向上递推得到最终答案。在暴力法中， 我们通过分析子问题， 其实就已经找到了动态规划所谓的状态转移方程：当前格子的走法就是右格子和下格子走法之和， 翻译成代码就是

```
 dp[i][j] = dp[i-1][j] + dp[i][j-1];
```

这里状态空间的定义是 [i] [j] 处到终点的路径数量。得到状态及其转移方程， 就考虑进行记忆化搜索， 进而转化成递推

### 动态规划问题特点

* 最优子结构

* 重复子问题

* 无后效性

  动态规划关注的是阶段性的结果， 而不关注得到结果的“路径”（回溯通常关注的问题）。 后阶段的决策不会影响之前的结果

### 动态规划问题的思考路径

* 根据问题来设计状态，状态空间（DP-table， 通常会需要额外的一行一列来避免if-else判断）

* 确定状态转移方程   就是枚举状态之间相互转化的可能， 分类讨论 （关注边界问题很重要， 要保证边界得到妥善处理）

* base case， 确定状态空间的初始值   这决定了递推从0还是1开始

* 考虑返回值   返回值可能是最后一个状态中的某一个， 也可能是整个状态空间中的最优值

* 考虑是否可以使用滚动数组或滚动变量来优化空间复杂度

  