学习笔记

## 哈希表（Hash Table）

![hash table](https://blog.kdchang.cc/2016/09/23/javascript-data-structure-algorithm-dictionary-hash-table/hash-table-head.png)

图源：https://blog.kdchang.cc/2016/09/23/javascript-data-structure-algorithm-dictionary-hash-table/

* 又称散列表
* 由数组演化而来， 也支持随机访问的特性。 通过把关键码值映射到表中的一个位置来访问记录， 加快查找速度
* 负责映射的函数称作散列函数， 记录数据的数组称作哈希表
* 工程应用有Redis中键值对存储，word拼写检测
* C++ 中的unordered_map， python中的dict（高版本中是有序的）

##### 散列冲突

* 指的是不同的键值通过散列函数映射到同一地址的情况， 很难找到一个完美无冲突的散列函数。

* 当散列表中空闲位置不多的时候， 散列冲突的概率就会大大提高，导致性能下降。

* 使用**装载因子**（load factor） 来表示空位的多少

  ```
  散列表的装载因子=填入表中的元素个数/散列表的长度
  ```

* 可能会被设计好的数据造成大量冲突， 使得服务器性能被占用（散列碰撞攻击）

解决方案：

1. 开放寻址法

   如果出现了散列冲突， 就重新寻找一个空闲的位置。

   寻找新位置的方式

   * 线性探测
   * 二次探测
   * 双重散列

   优点：

   * 不需要拉出链表， 可以有效利用CPU缓存加快查询速度
   * 更容易序列化

   缺点

   * 删除数据较为麻烦， 需要进行特殊标记
   * 所有数据都存储在一个数组中， 更容易发生冲突

   当数据量较小较为适合

2. 链表法

   在散列表中的每个地址上存储的不再是单独的一个元素， 而是对应一个链表（有时也可以是红黑树，跳表）， 所有散列值相同的元素我们都放到相同地址对应的链表中。

   优点：

   * 对内存的利用率高（链表可以需要时再创建）
   * 对大装载因子容忍度更高， 对于大装载因子， 也只是链表长度变长了

   更适合存储大对象， 大数据量的散列表

##### 散列表的动态扩容

* 类似于数组的动态扩容， 但是要更为复杂。 因为散列表的大小变了， 数据的存储位置也发生了改变， 需要通过散列函数重新计算位置。 通过装载因子来决定扩容和缩容的阈值。 装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。
* 避免低效的扩容： 不使用”一次性“扩容， 即不一次性将旧的哈希表的值都搬到新的哈希表中； 而是只申请新的哈希表的空间， 当有新数据插入时， 将新数据插入到新的哈希表中， 并且从旧的哈希表中拿出一个数据加入到新的哈希表中。（均摊了复杂度）   期间的查询操作是先从新的哈希表中查询， 如果未找到就去旧的哈希表中查找 。

##### 散列表与链表

散列表虽然支持高效的数据插入，删除和查找， 但是散列表中的数据是无规律存储的，无法按照顺序快速遍历。将链表结合上散列表可以解决这个问题

![](https://static001.geekbang.org/resource/image/ea/6e/eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg)

额外加入一个hnext指针

### python dict的分析



## 二叉树











